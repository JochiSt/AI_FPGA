"""
    script to convert the network using HLS4ML in HDL code
"""

import os
#os.environ['PATH'] = '/opt/Xilinx/Vivado/2019.2/bin:' + os.environ['PATH']
os.environ['PATH'] = '/opt/Xilinx/Vivado/2020.1/bin:' + os.environ['PATH']

# use the already trained model
from tensorflow.keras.models import load_model
model = load_model('storedANN/sine_v0.1.h5')

# evaluate model and make some plots
# TODO

# Convert the model to FPGA firmware with hls4ml
# Now we will go through the steps to convert the model we trained to a
# low-latency optimized FPGA firmware with hls4ml.
# First, we will evaluate its classification performance to make sure we
# haven't lost accuracy using the fixed-point data types.
# Then we will synthesize the model with Vivado HLS and check the metrics of
# latency and FPGA resource usage.

# Make an hls4ml config & model
# The hls4ml Neural Network inference library is controlled through a
# configuration dictionary.
# In this example we'll use the most simple variation, later exercises will
# look at more advanced configuration.

import hls4ml
from print_dict import print_dict
config = hls4ml.utils.config_from_keras_model(model, granularity='model')
print("-----------------------------------")
print("Configuration")
print_dict(config)
print("-----------------------------------")
hls_model = hls4ml.converters.convert_from_keras_model(model,
                            hls_config=config,
                            project_name='sinetest',
                            output_dir='sinetest',
                            part='xcu250-figd2104-2L-e')

# Let's visualise what we created. The model architecture is shown,
# annotated with the shape and data types
hls4ml.utils.plot_model(hls_model,
                        show_shapes=True,
                        show_precision=True,
                        to_file=model.name+"hls4ml.png"
                        )

# Compile, predict
# Now we need to check that this model performance is still good. We compile
# the hls_model, and then use `hls_model.predict` to execute the FPGA firmware
# with bit-accurate emulation on the CPU.
hls_model.compile()
#X_test = np.ascontiguousarray(X_test)
#y_hls = hls_model.predict(X_test)

# compare to Keras
# TODO

# Synthesize
# Now we'll actually use Vivado HLS to synthesize the model. We can run the
# build using a method of our `hls_model` object. After running this step, we
# can integrate the generated IP into a workflow to compile for a specific
# FPGA board. In this case, we'll just review the reports that Vivado HLS
# generates, checking the latency and resource usage.
#
# **This can take several minutes.**
#
# While the C-Synthesis is running, we can monitor the progress looking at the
# log file by opening a terminal from the notebook home, and executing:
#
# `tail -f model_1/hls4ml_prj/vivado_hls.log`

hls_model.build(
                csim=False,  #
                export=False # somehow the export fails
                )

# Check the reports
# Print out the reports generated by Vivado HLS. Pay attention to the Latency
# and the 'Utilization Estimates' sections

hls4ml.report.read_vivado_report('sinetest')
